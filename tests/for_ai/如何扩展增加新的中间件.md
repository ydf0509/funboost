
# 0 ai如何在 funboost如何固定方式扩展增加新的broker中间件(或者定制和现有broker_kind不一样的功能)

**funboost 扩展新的broker中间件，可以分为3种方式**

- 第一种方式是，静态扩展中间件。因为我是funboost作者，所以我可以在funboost框架的文件夹源码中直接增加写死代码。（这种只适合我本人，用户不能在funboost文件夹中写代码，而且只有最核心必须的中间件代码才推荐使用这种方式）

- 第二种方式是，动态扩展中间件，按照教程 `funboost_all_docs.md` 4.21章节,``4.21 【完全自由定制扩展（方式1）】 使用 `register_custom_broker` 完全彻底自由灵活自定义扩展和定制修改中间件(消费者和发布者)``

- 第三种方式是，动态扩展中间件，按照教程 `funboost_all_docs.md` 4.21b章节,``4.21b 【完全自由定制扩展(方式2)】,使用 `consumer_override_cls` 和 `publisher_override_cls` 来自定义消费者 发布者。``


# 1. 介绍 第一种方式，静态扩展中间件

静态扩展中间件，就是需要直接在funboost/consumers 和 funboost/publishers 中增加代码文件来写代码

## 静态扩展broker时候，需要修改以下文件

### funboost_config_deafult.py 中的 BrokerConnConfig 增加
如果新中间件需要连接配置（如 SQS 的 region、access_key 等固定连接配置），需要在这里添加配置项

### 在 funboost/core/broker_kind__exclusive_config_default_define.py 
 增加可额外传递独特的broker动态参数

### 在 funboost/publishers 增加 publisher

### 在 funboost/consumers 增加 consumer

### 在 funboost/constant.py  BrokerEnum 增加枚举

### 在 funboost/factories/broker_kind__publsiher_consumer_type_map.py 
 regist_to_funboost 注册publisher和consumer

### 静态扩展时候，任然可以参考文档的 funboost_all_docs_and_codes.md 中教程的 4.21 章节，知道要继承重写父类哪些方法。  
4.21 是动态扩展broker，ai在增加中间件时候，不必动态，直接把代码写死在funboost项目中就可以了


当动态扩展中间件时候，不要修改以上文件。


# 2. `register_custom_broker` 动态扩展中间件

register_custom_broker，这种更适合扩展全新的不存在中间件

动态新增中间件，就是不在 funboost/consumers 和 funboost/publishers 中写代码

ai可以参考文档 `funboost_all_docs_and_codes.md` 中教程的 4.21 章节
ai可以参考 `funboost/contrib/register_custom_broker_contrib` 目录下的代码，这些是动态扩展新的中间件。



# 3. `consumer_override_cls` 和 `publisher_override_cls` 动态扩展中间件

这种虽然也可以扩展全新的中间件，但更倾向于覆盖修改父类逻辑，定制用户自己的逻辑，将逻辑混入到各种broker中。

ai可以参考文档 `funboost_all_docs_and_codes.md` 中教程的 4.21b 章节

ai可以参考 `funboost/contrib/override_publisher_consumer_cls` 目录下的代码，这些是覆盖父类定制逻辑。


----------------


# publisher 和 consumer 如何写

## Publisher 继承 AbstractPublisher，需要实现的方法：

- `custom_init()` - 可选，自定义初始化
- `_publish_impl(msg: str)` - **必须实现**，发布消息的核心逻辑
- `clear()` - **必须实现**，清空队列，
- `get_message_count()` - **必须实现**，获取队列消息数量
- `close()` - **必须实现**，关闭连接，这个方法可以写pass，因为funboost不会自动停止，是永久运行的。


##  Consumer 继承 AbstractConsumer，需要实现的方法：

- `custom_init()` - 可选，自定义初始化
- `_dispatch_task()` - **必须实现**，从中间件取出消息，循环调用 `self._submit_task(kw)`
- `_confirm_consume(kw)` - **必须实现**，确认消费（ack）
- `_requeue(kw)` - **必须实现**，消息重入队

##  kw 字典必须包含的字段：

```python
kw = {
    'body': message_body,  # 消息体，消息体包含了函数入参大全，以及extra 这个key中有各种辅助字段
    # 其他用于 ack/requeue 的辅助字段，每种broker都不一样，如：
    # 'receipt_handle': ...,  # SQS 用
    # 'message': ...,         # AMQP 用
    # 'channel': ...,         # RabbitMQ 用
}
self._submit_task(kw)
```

## broker特有独有配置访问规范：

- `broker_exclusive_config` 中的配置**必须使用中括号 `[]` 访问**，不要用 `.get()`
- 默认值最好在 `broker_kind__exclusive_config_default_define.py` 中的 `register_broker_exclusive_config_default` 函数进行声明，方便用户知道可以传递哪些
- 如果 key 不存在会直接抛出 KeyError，便于发现问题

- 在consumer类中通过 self.consumer_params.broker_exclusive_config['$key'] 访问
- 在publisher类中通过 self.publisher_params.broker_exclusive_config['$key'] 访问

## ai可以参考的

ai 可以参考里面的funboost/publishers 和 funboost/consumers 其他broker写法。

ai 可以参考文档 `funboost_all_docs_and_codes.md` 中教程的 4.21 和 4.21b 章节

ai可以参考 `funboost/contrib/override_publisher_consumer_cls` 目录下的代码,这些是动态扩展中间件。

## ai编程不需要过度保守防御性编程

例如写过多的try，对确定的字典进行get


# 编写测试代码 
增加扩展新的中间件后，需要在 test_frame/ 目录下编写测试验证功能
在 test_frame/ 目录下新建一个文件夹，编写测试验证功能

**ai注意：**
ai agent在运行 funboost 测试代码时候，让funboost运行1分钟左右，然后kill。
如果funboost时间太短，可能还没来得及启动消费
如果不主动kill，funboost不会自动结束的，因为funboost设计成了无限循环消费
