
# 1 ai如何在 funboost如何固定方式扩展增加新的broker中间件

## funboost_config_deafult.py 中的 BrokerConnConfig 增加
 如果新中间件需要连接配置（如 SQS 的 region、access_key 等固定连接配置），需要在这里添加配置项

## 在 funboost/core/broker_kind__exclusive_config_default_define.py 
 增加可额外传递独特的broker动态参数

## 在 funboost/publishers 增加 publisher

## 在 funboost/consumers 增加 consumer

## 在 funboost/constant.py  BrokerEnum 增加枚举

## 在 funboost/factories/broker_kind__publsiher_consumer_type_map.py 
 regist_to_funboost 注册publisher和consumer

## 可以参考文档的 funboost_all_docs_and_codes.md 中教程的 4.21 章节
 普通用户如何不修改funboost动态扩展broker

4.21 是动态扩展broker，ai在增加中间件时候，不必动态，直接把代码写死在funboost项目中就可以了

## 编写测试代码 
  在 test_frame/ 目录下编写测试验证功能

# 2 publisher 和 consumer 如何写

## 2.1 Publisher 继承 AbstractPublisher，需要实现的方法：

- `custom_init()` - 可选，自定义初始化（如读取 broker_exclusive_config、创建客户端连接）
- `_publish_impl(msg: str)` - **必须实现**，发布消息的核心逻辑
- `clear()` - **必须实现**，清空队列，
- `get_message_count()` - **必须实现**，获取队列消息数量
- `close()` - **必须实现**，关闭连接，可以写pass


## 2.2 Consumer 继承 AbstractConsumer，需要实现的方法：

- `custom_init()` - 可选，自定义初始化
- `_dispatch_task()` - **必须实现**，从中间件取出消息，循环调用 `self._submit_task(kw)`
- `_confirm_consume(kw)` - **必须实现**，确认消费（ack）
- `_requeue(kw)` - **必须实现**，消息重入队

## 2.3 kw 字典必须包含的字段：

```python
kw = {
    'body': message_body_str,  # 必须，消息体字符串
    # 其他用于 ack/requeue 的字段，如：
    # 'receipt_handle': ...,  # SQS 用
    # 'message': ...,         # AMQP 用
    # 'channel': ...,         # RabbitMQ 用
}
self._submit_task(kw)
```

## 2.4 配置访问规范：

- `broker_exclusive_config` 中的配置**必须使用中括号 `[]` 访问**，不要用 `.get()`
- 默认值已在 `broker_kind__exclusive_config_default_define.py` 中声明
- 如果 key 不存在会直接抛出 KeyError，便于发现问题


## 2.5 ai可以参考的

ai 可以参考里面的funboost/publishers 和 funboost/consumers 其他broker写法。

## 2.6 ai编程不需要过度保守防御性编程

例如写过多的try，对确定的字典进行get


# 3 动态新增中间件，不在 consumers和publishers中写代码

## 3.1 参考文档 funboost_all_docs_and_codes.md 中教程的 4.21 章节

## 3.2 参考funboost/contrib目录下的代码
